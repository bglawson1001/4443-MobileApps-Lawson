## Mongo Db's and Collections

MongoDB organizes its data into `databases` and each `database` organizes data within in `collections`. A `collection` is made up of documents, where a document is simply a json object (basically). This is a straightforward approach, but just like anything else, there are preferences, standards, opinions, etc..

For organizing our candy data we have a few options, each with its own advantages and potential drawbacks. Of course this always depends on the complexity of the data, where choices would depend on factors like the expected size of the dataset, how we plan to query the data, and MongoDB's limitations and best practices. 

Using our candy data, there's really only three options, where option two is the best (in my opinion), but you should see different ways of doing things. 

### Option 1: Single Collection with Embedded Documents
You could use a single database with a single collection, where each document represents a candy category, and each category contains an array of candies as embedded documents.

**Advantages:**
- Simplifies queries if you often retrieve all candies within a category.
- Maintains data locality, which can be beneficial for read performance.

**Example Structure:**
```json
{
  "_id": "gummy-candy",
  "candies": [
    {
      "id": "42688376078523",
      "name": "Sour Patch Kids Assorted - 5lb",
      ...
    },
    {
      "id": "42688605716667",
      "name": "Peach Os Gummi Rings - 5lb",
      ...
    }
  ]
}
```

### Option 2: Single Collection with a Category Field
Alternatively, you could have a single collection where each document is a candy, and each candy document includes a category field.

**Advantages:**
- Flexible and straightforward for queries, especially if you frequently query individual candies across different categories.
- Easier to manage indexes for queries on candy attributes.

**Example Structure:**
```json
{
  "id": "42688376078523",
  "category": "gummy-candy",
  "name": "Sour Patch Kids Assorted - 5lb",
  ...
}
```

### Option 3: Multiple Collections
You could also use a single database with multiple collections, one for each candy category.

**Advantages:**
- Separates data logically at the collection level, which might be beneficial if categories have very different access patterns or if the dataset is very large.

**Drawbacks:**
- More complex to manage, especially if the number of categories changes over time.
- Queries across multiple categories can be more challenging.

**MongoDB Naming Conventions:**
- Database and collection names should be lowercase, with words separated by underscores or dashes for readability.
- Avoid using reserved words or characters that are not allowed in directory and file names.
- Be concise but descriptive enough to understand the purpose of the database or collection.

**Given Our Candy Data:**
Given the structure of our data and assuming the categories have similar access patterns and the dataset size is manageable, **Option 2** offers a good balance between simplicity and flexibility. This approach allows us to easily query candies across categories, maintain efficient indexing, and avoid the complexity of managing many collections. The database could be named something like `candy_store`, and the collection could be named something like `candies`. The nameing of db's and collections should have some logical association: `candies` are contained by a `candy_store`, or `employees` work in a `candy_store`, etc..

-----

## Mongo Id's

Mongodb will autogenerate a unique object id if you don't provide one. The catch is, you need to name the id field of your document: **`_id`**. Anything else, even the straightforward **`id`** will not stop mongo from creating its own **`_id`** field. However! It's not all bad. 

The autogenerated MongoDB ObjectId holds additional information within its value, which can be quite useful. An ObjectId in MongoDB is a 12-byte hexadecimal value, which consists of:

1. **Timestamp**: The first 4 bytes represent the ObjectId's creation timestamp, measured in seconds since the Unix epoch. This allows you to determine the approximate creation time of a document directly from its ObjectId.

2. **Machine Identifier**: The next 3 bytes are derived from the machine's hostname on which the MongoDB instance is running. This helps ensure uniqueness across different machines.

3. **Process ID**: Following the machine identifier, the next 2 bytes come from the process ID of the MongoDB server process that created the ObjectId. This further aids in ensuring uniqueness, particularly on machines running multiple MongoDB server processes.

4. **Increment**: The last 3 bytes are an incrementing counter, initialized to a random value. While the counter is primarily for ensuring uniqueness within a single second, it can also help determine the order in which ObjectIds were generated, albeit with some limitations due to its size and the way it wraps.

By examining an ObjectId, you can extract the timestamp, which can be particularly useful for debugging or for applications where the creation time of the document is relevant but hasn't been explicitly stored in a separate field. However, relying on ObjectId for detailed information beyond the creation timestamp is generally not recommended due to the opaque nature of the other components and their primary purpose of ensuring uniqueness rather than storing meaningful data.

To get the timestamp from an ObjectId in Python using `pymongo`, you can do something like this:

```python
from bson.objectid import ObjectId
from datetime import datetime

# Assuming `obj_id` is your ObjectId
obj_id = ObjectId("507f191e810c19729de860ea")

# Extract the timestamp
timestamp = obj_id.generation_time  # This is a datetime object in UTC

print(f"Timestamp: {timestamp}")
```

This will give you the date and time when the ObjectId was generated, which can be quite handy for understanding the age of documents or for ordering them by creation time in the absence of a dedicated timestamp field.

-----

## GET Requests

Assuming the following document structure:

```json
{
  "id": "42688376078523",
  "category": "gummy-candy",
  "name": "Sour Patch Kids Assorted - 5lb",
  ...
}
```

Let's query candy documents in a variety of ways:

### 1. Fetch a Document by ID
To get a specific candy item using its unique ID, you'd use the `find_one` method with the ID as the search criterion.

```python
from pymongo import MongoClient

# Connect to the MongoDB client and select the database and collection
client = MongoClient('mongodb://localhost:27017/')
db = client.your_database_name  # Replace with your actual database name
collection = db.your_collection_name  # Replace with your actual collection name

# Fetch a document by its ID
candy_id = "42688376078523"
candy_item = collection.find_one({"id": candy_id})

print(candy_item)
```

### 2. Fetch All Candies in a Category
To get all candies belonging to a specific category like "gummy-candy", you'd use the `find` method.

```python
# Get all candies in the "gummy-candy" category
gummy_candies = collection.find({"category": "gummy-candy"})

for candy in gummy_candies:
    print(candy)
```

### 3. Fetch Candies with Name Matching a Pattern
If you want to get all candies with names that include a certain word or pattern, like "Sour", you can use a regex query.

```python
import re

# Fetch candies with "Sour" in their name
sour_candies = collection.find({"name": {"$regex": re.compile("Sour", re.IGNORECASE)}})

for candy in sour_candies:
    print(candy)
```

### 4. Fetch a Limited Number of Documents Sorted by Name
To get, for example, the first 5 candy items sorted alphabetically by their name, you can use `find` with `sort` and `limit`.

```python
# Fetch the first 5 candies sorted by name
sorted_candies = collection.find().sort("name", 1).limit(5)

for candy in sorted_candies:
    print(candy)
```

### 5. Fetch Candies with a Combination of Criteria
You can also combine criteria, like getting all "gummy-candy" items that have "Sour" in their name.

```python
# Fetch gummy candies with "Sour" in their name
sour_gummy_candies = collection.find({"category": "gummy-candy", "name": {"$regex": re.compile("Sour", re.IGNORECASE)}})

for candy in sour_gummy_candies:
    print(candy)
```

## PUT Requests

Assuming the following document structure:

```json
{
  "id": "42688376078523",
  "category": "gummy-candy",
  "name": "Sour Patch Kids Assorted - 5lb",
  ...
}
```

Let's update values in candy documents in a variety of ways:

### 1. Update a Single Field
To update a simple field, like changing the category of a specific candy, you can use `update_one` with the `set` operator.

```python
# Update the category of a specific candy by its ID
candy_id = "42688376078523"
new_category = "chocolate"
collection.update_one({"id": candy_id}, {"$set": {"category": new_category}})
```

### 2. Update Multiple Fields
You can also update multiple fields in a single operation. For instance, you might want to update the name and category of a candy at the same time.

```python
# Update the name and category of a candy
new_name = "Sour Patch Kids Extreme - 5lb"
collection.update_one({"id": candy_id}, {"$set": {"name": new_name, "category": new_category}})
```

### 3. Incrementing a Numeric Value
Suppose you have a `stock` field representing the number of items available. You can increment this field without first reading its value.

```python
# Increment the stock of a candy item
stock_increment = 10
collection.update_one({"id": candy_id}, {"$inc": {"stock": stock_increment}})
```

### 4. Adding to an Array Field
If you have an array field, such as `flavors` in each candy document, you can add a new flavor using the `$push` operator.

```python
# Add a new flavor to the candy's flavor list
new_flavor = "Blue Raspberry"
collection.update_one({"id": candy_id}, {"$push": {"flavors": new_flavor}})
```

### 5. Conditional Updates with `$set` and `$unset`
You can conditionally update documents based on their existing content. For example, if a candy has a `discontinued` field set to `true`, you might want to remove that field.

```python
# Remove the 'discontinued' field if it's set to true
collection.update_many({"discontinued": True}, {"$unset": {"discontinued": ""}})
```

### Advanced: Using `$set` with Embedded Documents
If your documents contain embedded documents or nested fields, you can update these using dot notation.

```python
# Update a nested field within an embedded document
collection.update_one({"id": candy_id}, {"$set": {"nutrition.sugarContent": "80g"}})
```

- MongoDB updates are powerful and flexible, allowing you to make changes across simple and complex document structures. 
- Always ensure you're operating on the correct documents by using precise query filters. 
- Lastly consider the implications of `update_one` vs. `update_many` depending on whether you intend to update a single document or multiple documents matching your query criteria.
